/* Copyright (C) 2010 The giomm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glibmm/object.h>

_DEFS(giomm,gio)
_PINCLUDE(glibmm/private/object_p.h)

namespace Gio
{

/** A Socket control message.
 * A %SocketControlMessage is a special-purpose utility message that can be
 * sent to or received from a Socket. These types of messages are often
 * called "ancillary data".
 *
 * The message can represent some sort of special instruction to or
 * information from the socket or can represent a special kind of transfer to
 * the peer (for example, sending a file description over a UNIX socket).
 *
 * These messages are sent with Gio::Socket::send() and received with
 * Gio::Socket::receive().
 *
 * To extend the set of control message that can be sent, subclass this class
 * and override the get_size_vfunc(), get_level_vfunc(), get_type_vfunc() and
 * serialize_vfunc() methods.
 *
 * To extend the set of control messages that can be received, subclass this
 * class and implement the deserialize method. Also, make sure your class is
 * registered with the GType typesystem before calling
 * Gio::Socket::receive() to read such a message.
 *
 * @ingroup NetworkIO
 * @newin{2,28}
 */
class SocketControlMessage : public Glib::Object
{
  _CLASS_GOBJECT(SocketControlMessage, GSocketControlMessage, G_SOCKET_CONTROL_MESSAGE, Glib::Object, GObject)

protected:
  _CTOR_DEFAULT

public:
  _WRAP_METHOD(static Glib::RefPtr<SocketControlMessage> deserialize(int level, int type, gsize size, gpointer data), g_socket_control_message_deserialize)
  _WRAP_METHOD(int get_level() const, g_socket_control_message_get_level)
  _WRAP_METHOD(int get_msg_type() const, g_socket_control_message_get_msg_type)
  _WRAP_METHOD(gsize get_size() const, g_socket_control_message_get_size)
  _WRAP_METHOD(void serialize(gpointer data), g_socket_control_message_serialize)

  _WRAP_VFUNC(gsize get_size() const, "get_size")
  _WRAP_VFUNC(int get_level() const, "get_level")
  _WRAP_VFUNC(int get_type() const, "get_type")
  _WRAP_VFUNC(void serialize(gpointer data), "serialize")

protected:
  // The deserialize vfunc in GLib is a class virtual function (not associated
  // with an instance). Such functions don't exist in C++.
  // But it must be wrapped in one way or another. g_socket_control_message_deserialize()
  // assumes that all subclasses of GSocketControlMessage override this vfunc.
  // A user-program can crash, if any subclass does not.
  // https://gitlab.gnome.org/GNOME/glibmm/issues/52
#m4begin
  _PUSH(SECTION_PCC_CLASS_INIT_VFUNCS)
  klass->deserialize = &deserialize_vfunc_callback;
  _SECTION(SECTION_PH_VFUNCS)
  //TODO: Uncomment when we can add API.
  //static GSocketControlMessage* deserialize_vfunc_callback(
  //  int level, int type, gsize size, gpointer data);
  _POP()
#m4end

  //TODO: When we can add API, add protected DeserializeFunc,
  // add_deserialize_func() and private m_deserialize_funcs from the master branch.
  // And update the last paragraph of the class description.
};

} // namespace Gio
