/* Copyright (C) 2010 Jonathon Jongsma
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <glibmm/arrayhandle.h>
#include <glibmm/object.h>
#include <glibmm/variant.h>

_DEFS(giomm,gio)
_PINCLUDE(glibmm/private/object_p.h)

namespace Gio
{

  _WRAP_ENUM(SettingsBindFlags, GSettingsBindFlags)

/** A high-level API for application settings
 *
 * The Settings class provides a convenient API for storing and retrieving
 * application settings.
 *
 * @newin{2,28}
 */
class Settings : public Glib::Object
{
  _CLASS_GOBJECT(Settings, GSettings, G_SETTINGS, Glib::Object, GObject)

protected:
  _WRAP_CTOR(Settings(const Glib::ustring& schema), g_settings_new)
  _WRAP_CTOR(Settings(const Glib::ustring& schema, const Glib::ustring& path), g_settings_new_with_path)
  //TODO: Requires SettingsBackend: _WRAP_CTOR(Settings(const Glib::ustring& schema, const Glib::RefPtr<SettingsBackend>& backend), g_settings_new_with_backend)
  //TODO: Requires SettingsBackend: _WRAP_CTOR(Settings(const Glib::ustring& schema, const Glib::RefPtr<SettingsBackend>& backend, const Glib::ustring& path), g_settings_new_with_backend_and_path)

public:
  _WRAP_CREATE(const Glib::ustring& schema)
  _WRAP_CREATE(const Glib::ustring& schema, const Glib::ustring& path)
  //TODO: Requires SettingsBackend: _WRAP_CREATE(const Glib::ustring& schema, const Glib::RefPtr<SettingsBackend>& backend)
  //TODO: Requires SettingsBackend: _WRAP_CREATE(const Glib::ustring& schema, const Glib::RefPtr<SettingsBackend>& backend, const Glib::ustring& path)

  _WRAP_METHOD(bool set_value(const Glib::ustring& key, const Glib::VariantBase& value),  g_settings_set_value)

  /** Gets the value that is stored in the settings for a @a key.
   *
   * It is a programmer error to give a @a key that isn't contained in the
   * schema for the settings.
   *
   * @param key The key to get the value for.
   * @param value A Variant of the expected type.
   *
   * @newin{2,28}
   */
  void get_value(const Glib::ustring& key, Glib::VariantBase& value) const;
  _IGNORE(g_settings_get_value)

  _WRAP_METHOD(int get_int(const Glib::ustring& key) const, g_settings_get_int)
  _WRAP_METHOD(void set_int(const Glib::ustring& key, int value), g_settings_set_int)
  _WRAP_METHOD(bool get_boolean(const Glib::ustring& key) const, g_settings_get_boolean)
  _WRAP_METHOD(void set_boolean(const Glib::ustring& key, bool value), g_settings_set_boolean)
  _WRAP_METHOD(Glib::ustring get_string(const Glib::ustring& key) const, g_settings_get_string)
  _WRAP_METHOD(void set_string(const Glib::ustring& key, const Glib::ustring& value), g_settings_set_string)
  _WRAP_METHOD(double get_double(const Glib::ustring& key) const, g_settings_get_double)
  _WRAP_METHOD(void set_double(const Glib::ustring& key, double value), g_settings_set_double)

  #m4 _CONVERSION(`gchar**',`Glib::StringArrayHandle',`Glib::StringArrayHandle($3, Glib::OWNERSHIP_DEEP)')
  _WRAP_METHOD(Glib::StringArrayHandle get_string_array(const Glib::ustring& key) const, g_settings_get_strv)

  _WRAP_METHOD(bool set_string_array(const Glib::ustring& key,  const Glib::StringArrayHandle& value), g_settings_set_strv)

  _WRAP_METHOD(int get_enum(const Glib::ustring& key) const, g_settings_get_enum )
  _WRAP_METHOD(bool get_enum(const Glib::ustring& key, int value), g_settings_set_enum)
  _WRAP_METHOD(guint get_flags(const Glib::ustring& key) const, g_settings_get_flags)
  _WRAP_METHOD(bool get_flags(const Glib::ustring& key, guint value), g_settings_set_flags)

  // Ignore varargs functions.
  _IGNORE(g_settings_get, g_settings_set)

  _WRAP_METHOD(Glib::RefPtr<Settings> get_child(const Glib::ustring& name), g_settings_get_child)
  _WRAP_METHOD(Glib::RefPtr<const Settings> get_child(const Glib::ustring& name) const, g_settings_get_child, constversion)
  _WRAP_METHOD(bool is_writable(const Glib::ustring& key) const, g_settings_is_writable)

  _WRAP_METHOD(void delay(), g_settings_delay)
  _WRAP_METHOD(void apply(), g_settings_apply)
  _WRAP_METHOD(void revert(), g_settings_revert)
  _WRAP_METHOD(bool get_has_unapplied() const, g_settings_get_has_unapplied)

  _WRAP_METHOD(void reset(const Glib::ustring& key), g_settings_reset)

//We must hand-code this because gmmproc is confused by the static keyword with the vector.
//#m4 _CONVERSION(`const gchar*const*',`std::vector<Glib::ustring>',`Glib::ArrayHandler<Glib::ustring>::array_to_vector($3, Glib::OWNERSHIP_NONE)')
  _WRAP_METHOD_DOCS_ONLY(g_settings_list_schemas)
  static std::vector<Glib::ustring> list_schemas();
  _IGNORE(g_settings_list_schemas)

#m4 _CONVERSION(`gchar**',`std::vector<Glib::ustring>',`Glib::ArrayHandler<Glib::ustring>::array_to_vector($3, Glib::OWNERSHIP_DEEP)')
  _WRAP_METHOD(std::vector<Glib::ustring> list_children() const, g_settings_list_children)
  _WRAP_METHOD(std::vector<Glib::ustring> list_keys() const, g_settings_list_keys)

  //TODO: Choose an appropriate Variant template type: GVariant* g_settings_get_range(const gchar* key)

  _WRAP_METHOD(bool range_check(const Glib::ustring& key, const Glib::VariantBase& value) const, g_settings_range_check)

#m4 _CONVERSION(`Glib::ObjectBase*',`gpointer',(gpointer)$3->gobj())
  _WRAP_METHOD(void bind(const Glib::ustring& key, Glib::ObjectBase* object, const Glib::ustring& property, SettingsBindFlags flags=SETTINGS_BIND_DEFAULT), g_settings_bind)
  void bind(const Glib::ustring& key, const Glib::PropertyProxy_Base& property_proxy, SettingsBindFlags flags=SETTINGS_BIND_DEFAULT);
  // TODO: implement bind_with_mapping
  _WRAP_METHOD(void bind_writable(const Glib::ustring& key, Glib::ObjectBase* object, const Glib::ustring& property, bool inverted=false), g_settings_bind_writable)
  void bind_writable(const Glib::ustring& key, const Glib::PropertyProxy_Base& property_proxy, bool inverted=false);
  // TODO: unbind is not actually a class method

  //TODO?: _WRAP_SIGNAL(bool change_event(const Glib::ArrayHandle<Glib::QueryQuark>& keys, int n_keys), "change-event")

#m4 _CONVERSION(`const char*',`const Glib::ustring&',__GCHARP_TO_USTRING)
  _WRAP_SIGNAL(void changed(const Glib::ustring& key), "changed")

  _WRAP_SIGNAL(bool writable_change_event(guint key), "writable-change-event")
  _WRAP_SIGNAL(void writable_changed(const Glib::ustring& key), writable_changed)
};

} // namespace Gio
